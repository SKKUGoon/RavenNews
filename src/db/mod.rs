pub mod stats;

use crate::rss::RssItem;
use sqlx::{PgPool, postgres::PgPoolOptions};

pub async fn create_pg_pool(database_url: &str) -> PgPool {
    PgPoolOptions::new()
        .max_connections(5)
        .connect(database_url)
        .await
        .expect("Failed to create PostgreSQL pool")
}

pub async fn insert_rss_item(pool: &PgPool, item: &RssItem) -> Result<bool, sqlx::Error> {
    // Checks if the row already exists (id, my deterministic hash UUID)
    // Returns true if inserted, false if skipped
    // Schema: warehouse, Table: rss_items
    let result = sqlx::query!(
        r#"
        INSERT INTO warehouse.rss_items (id, source, title, link, summary, published_at)
        VALUES ($1, $2, $3, $4, $5, $6)
        ON CONFLICT (id) DO NOTHING
        "#,
        item.id, // UUID generated by source + title + published_at
        item.source,
        item.title,
        item.link,
        item.summary,
        item.published_at,
    )
    .execute(pool)
    .await?;

    Ok(result.rows_affected() > 0)
}

#[cfg(test)]
mod tests {
    use super::*;
    use dotenvy::dotenv;

    #[tokio::test]
    async fn test_create_pg_pool() {
        dotenv().ok();

        let database_url = std::env::var("DATABASE_URL").expect("DATABASE_URL must be set");
        let pool = create_pg_pool(&database_url).await;

        let row: (i32,) = sqlx::query_as("SELECT 1")
            .fetch_one(&pool)
            .await
            .expect("Failed to run test query");
        assert_eq!(row.0, 1);
    }

    #[tokio::test]
    async fn test_insert_rss_item() {
        dotenv().ok();

        let database_url = std::env::var("DATABASE_URL").expect("DATABASE_URL must be set");
        let pool = create_pg_pool(&database_url).await;

        let item_with_summary = RssItem::new(
            "test1",
            "test1",
            "test1",
            Some("test1".to_string()),
            Some(chrono::Utc::now()),
        );

        let item_without_summary =
            RssItem::new("test1", "test1", "test1", None, Some(chrono::Utc::now()));

        assert!(insert_rss_item(&pool, &item_with_summary).await.unwrap());
        assert!(insert_rss_item(&pool, &item_without_summary).await.unwrap());
    }

    #[tokio::test]
    async fn test_insert_duplicate_rss_item() {
        dotenv().ok();

        let database_url = std::env::var("DATABASE_URL").expect("DATABASE_URL must be set");
        let pool = create_pg_pool(&database_url).await;
        let published_at = chrono::Utc::now();

        let item = RssItem::new(
            "test2",
            "test2",
            "test2",
            Some("test2".to_string()),
            Some(published_at),
        );

        // Shoule insert only once
        assert!(insert_rss_item(&pool, &item).await.unwrap()); // true
        assert!(!insert_rss_item(&pool, &item).await.unwrap()); // false; because it already exists
    }
}
